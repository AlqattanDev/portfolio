---
import '../styles/main.css';
import ProgressBar from '../components/ProgressBar.astro';
import StatusBar from '../components/StatusBar.astro';
import type { UserProfile } from '@/types/index.ts';

// Import profile data
import profileData from '../data/profile.json';

export const profile: UserProfile = profileData as UserProfile;
---

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ali - System Architect</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body class="digital-view">
    <!-- Progress Bar -->
    <ProgressBar />

    <!-- Bottom Status Bar Navigation -->
    <StatusBar />

    <div class="container page">
      <div class="content">
        <slot />
      </div>
    </div>

    <!-- Screen Reader Announcements -->
    <div
      id="sr-announcements"
      class="sr-only"
      aria-live="polite"
      aria-atomic="true"
    >
    </div>

    <script>
      // Import component enhancements
      import { initializeComponentEnhancements } from '@/utils/componentEnhancements';

      // Initialize component enhancements with performance optimizations
      initializeComponentEnhancements({
        enableScrollAnimations: true,
        enableThemeReactivity: true,
        enableInteractionEffects: true,
        staggerDelay: 0.04, // Faster animations for better responsiveness
      });

      // Core theme management functionality
      const themeToggle = document.getElementById('themeToggle');
      const html = document.documentElement;

      function updateTheme(theme: string) {
        try {
          html.setAttribute('data-theme', theme);

          // Safe localStorage operation
          try {
            localStorage.setItem('theme', theme);
          } catch (storageError) {
            // Failed to save theme preference
          }
        } catch (error) {
          // Failed to update theme
        }
      }

      // Initialize theme with fallback
      function initializeTheme() {
        let savedTheme = 'light'; // Default fallback

        try {
          if (typeof Storage !== 'undefined') {
            savedTheme = localStorage.getItem('theme') || 'light';
          }
        } catch (error) {
          // localStorage not available, using default theme
        }

        // Validate theme value
        if (!['light', 'dark'].includes(savedTheme)) {
          savedTheme = 'light';
        }

        updateTheme(savedTheme);
      }

      initializeTheme();

      if (themeToggle) {
        // Get reference to the animation system
        const animationSystem = window.asciiAnimationSystem;

        const toggleTheme = () => {
          try {
            // If animation system exists, use it to cycle schemes
            if (animationSystem) {
              animationSystem.nextScheme();
            } else {
              // Fallback to simple toggle if animation system not available
              const currentTheme = html.getAttribute('data-theme') || 'light';
              const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
              updateTheme(newTheme);
            }

            // Add subtle animation feedback
            themeToggle.style.transform = 'scale(0.95)';
            setTimeout(() => {
              themeToggle.style.transform = '';
            }, 150);
          } catch (error) {
            // Failed to toggle theme
          }
        };

        // Listen for theme:changed events from the animation system
        document.addEventListener('theme:changed', (e: Event) => {
          const customEvent = e as CustomEvent;
          if (customEvent.detail && customEvent.detail.theme) {
            themeToggle.setAttribute(
              'aria-pressed',
              customEvent.detail.theme === 'dark' ? 'true' : 'false'
            );
          }
        });

        themeToggle.addEventListener('click', toggleTheme);

        // Add keyboard support
        themeToggle.addEventListener('keydown', (e) => {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
            keyEvent.preventDefault();
            toggleTheme();
          }
        });
      }

      // Lazy load section observer with performance optimization
      const observeSections = () => {
        const navLinks = Array.from(
          document.querySelectorAll('.status-item')
        ) as HTMLAnchorElement[];
        if (navLinks.length === 0) return;

        const sections = navLinks
          .map(
            (l) =>
              document.querySelector(
                l.getAttribute('href')!
              ) as HTMLElement | null
          )
          .filter(Boolean) as HTMLElement[];

        if (sections.length === 0) return;

        // Debounce utility
        function debounce(func: (...args: unknown[]) => void, wait: number) {
          let timeout: number;
          return function executedFunction(...args: unknown[]) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }

        // Debounced intersection handler
        const debouncedHandler = debounce(
          (entries: IntersectionObserverEntry[]) => {
            entries.forEach((entry) => {
              const id = entry.target.getAttribute('id');
              if (!id) return;
              const link = navLinks.find(
                (l) => l.getAttribute('href') === `#${id}`
              );
              if (!link) return;
              if (entry.isIntersecting) {
                requestAnimationFrame(() => {
                  navLinks.forEach((a) => a.classList.remove('active'));
                  link.classList.add('active');
                });
              }
            });
          },
          50
        );

        const observer = new IntersectionObserver(debouncedHandler, {
          rootMargin: '-40% 0px -55% 0px',
          threshold: [0, 0.25, 0.6, 1],
        });

        sections.forEach((sec) => observer.observe(sec));
      };

      // Initialize section observer after a short delay
      setTimeout(observeSections, 100);
    </script>

    <!-- Global styles are now imported via main.css -->
  </body>
</html>
